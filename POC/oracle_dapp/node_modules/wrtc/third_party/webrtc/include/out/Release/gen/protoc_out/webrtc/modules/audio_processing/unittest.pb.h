// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: unittest.proto

#ifndef PROTOBUF_unittest_2eproto__INCLUDED
#define PROTOBUF_unittest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace webrtc {
namespace audioproc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_unittest_2eproto();
void protobuf_AssignDesc_unittest_2eproto();
void protobuf_ShutdownFile_unittest_2eproto();

class Test;
class Test_Frame;
class Test_Statistic;
class Test_EchoMetrics;
class Test_DelayMetrics;
class OutputData;

// ===================================================================

class Test_Frame : public ::google::protobuf::MessageLite {
 public:
  Test_Frame();
  virtual ~Test_Frame();

  Test_Frame(const Test_Frame& from);

  inline Test_Frame& operator=(const Test_Frame& from) {
    CopyFrom(from);
    return *this;
  }

  static const Test_Frame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Test_Frame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Test_Frame* other);

  // implements Message ----------------------------------------------

  Test_Frame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Test_Frame& from);
  void MergeFrom(const Test_Frame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.Frame)
 private:


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_unittest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_unittest_2eproto();
  #endif
  friend void protobuf_AssignDesc_unittest_2eproto();
  friend void protobuf_ShutdownFile_unittest_2eproto();

  void InitAsDefaultInstance();
  static Test_Frame* default_instance_;
};
// -------------------------------------------------------------------

class Test_Statistic : public ::google::protobuf::MessageLite {
 public:
  Test_Statistic();
  virtual ~Test_Statistic();

  Test_Statistic(const Test_Statistic& from);

  inline Test_Statistic& operator=(const Test_Statistic& from) {
    CopyFrom(from);
    return *this;
  }

  static const Test_Statistic& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Test_Statistic* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Test_Statistic* other);

  // implements Message ----------------------------------------------

  Test_Statistic* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Test_Statistic& from);
  void MergeFrom(const Test_Statistic& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 instant = 1;
  inline bool has_instant() const;
  inline void clear_instant();
  static const int kInstantFieldNumber = 1;
  inline ::google::protobuf::int32 instant() const;
  inline void set_instant(::google::protobuf::int32 value);

  // optional int32 average = 2;
  inline bool has_average() const;
  inline void clear_average();
  static const int kAverageFieldNumber = 2;
  inline ::google::protobuf::int32 average() const;
  inline void set_average(::google::protobuf::int32 value);

  // optional int32 maximum = 3;
  inline bool has_maximum() const;
  inline void clear_maximum();
  static const int kMaximumFieldNumber = 3;
  inline ::google::protobuf::int32 maximum() const;
  inline void set_maximum(::google::protobuf::int32 value);

  // optional int32 minimum = 4;
  inline bool has_minimum() const;
  inline void clear_minimum();
  static const int kMinimumFieldNumber = 4;
  inline ::google::protobuf::int32 minimum() const;
  inline void set_minimum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.Statistic)
 private:
  inline void set_has_instant();
  inline void clear_has_instant();
  inline void set_has_average();
  inline void clear_has_average();
  inline void set_has_maximum();
  inline void clear_has_maximum();
  inline void set_has_minimum();
  inline void clear_has_minimum();

  ::google::protobuf::int32 instant_;
  ::google::protobuf::int32 average_;
  ::google::protobuf::int32 maximum_;
  ::google::protobuf::int32 minimum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_unittest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_unittest_2eproto();
  #endif
  friend void protobuf_AssignDesc_unittest_2eproto();
  friend void protobuf_ShutdownFile_unittest_2eproto();

  void InitAsDefaultInstance();
  static Test_Statistic* default_instance_;
};
// -------------------------------------------------------------------

class Test_EchoMetrics : public ::google::protobuf::MessageLite {
 public:
  Test_EchoMetrics();
  virtual ~Test_EchoMetrics();

  Test_EchoMetrics(const Test_EchoMetrics& from);

  inline Test_EchoMetrics& operator=(const Test_EchoMetrics& from) {
    CopyFrom(from);
    return *this;
  }

  static const Test_EchoMetrics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Test_EchoMetrics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Test_EchoMetrics* other);

  // implements Message ----------------------------------------------

  Test_EchoMetrics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Test_EchoMetrics& from);
  void MergeFrom(const Test_EchoMetrics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .webrtc.audioproc.Test.Statistic residual_echo_return_loss = 1;
  inline bool has_residual_echo_return_loss() const;
  inline void clear_residual_echo_return_loss();
  static const int kResidualEchoReturnLossFieldNumber = 1;
  inline const ::webrtc::audioproc::Test_Statistic& residual_echo_return_loss() const;
  inline ::webrtc::audioproc::Test_Statistic* mutable_residual_echo_return_loss();
  inline ::webrtc::audioproc::Test_Statistic* release_residual_echo_return_loss();
  inline void set_allocated_residual_echo_return_loss(::webrtc::audioproc::Test_Statistic* residual_echo_return_loss);

  // optional .webrtc.audioproc.Test.Statistic echo_return_loss = 2;
  inline bool has_echo_return_loss() const;
  inline void clear_echo_return_loss();
  static const int kEchoReturnLossFieldNumber = 2;
  inline const ::webrtc::audioproc::Test_Statistic& echo_return_loss() const;
  inline ::webrtc::audioproc::Test_Statistic* mutable_echo_return_loss();
  inline ::webrtc::audioproc::Test_Statistic* release_echo_return_loss();
  inline void set_allocated_echo_return_loss(::webrtc::audioproc::Test_Statistic* echo_return_loss);

  // optional .webrtc.audioproc.Test.Statistic echo_return_loss_enhancement = 3;
  inline bool has_echo_return_loss_enhancement() const;
  inline void clear_echo_return_loss_enhancement();
  static const int kEchoReturnLossEnhancementFieldNumber = 3;
  inline const ::webrtc::audioproc::Test_Statistic& echo_return_loss_enhancement() const;
  inline ::webrtc::audioproc::Test_Statistic* mutable_echo_return_loss_enhancement();
  inline ::webrtc::audioproc::Test_Statistic* release_echo_return_loss_enhancement();
  inline void set_allocated_echo_return_loss_enhancement(::webrtc::audioproc::Test_Statistic* echo_return_loss_enhancement);

  // optional .webrtc.audioproc.Test.Statistic a_nlp = 4;
  inline bool has_a_nlp() const;
  inline void clear_a_nlp();
  static const int kANlpFieldNumber = 4;
  inline const ::webrtc::audioproc::Test_Statistic& a_nlp() const;
  inline ::webrtc::audioproc::Test_Statistic* mutable_a_nlp();
  inline ::webrtc::audioproc::Test_Statistic* release_a_nlp();
  inline void set_allocated_a_nlp(::webrtc::audioproc::Test_Statistic* a_nlp);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.EchoMetrics)
 private:
  inline void set_has_residual_echo_return_loss();
  inline void clear_has_residual_echo_return_loss();
  inline void set_has_echo_return_loss();
  inline void clear_has_echo_return_loss();
  inline void set_has_echo_return_loss_enhancement();
  inline void clear_has_echo_return_loss_enhancement();
  inline void set_has_a_nlp();
  inline void clear_has_a_nlp();

  ::webrtc::audioproc::Test_Statistic* residual_echo_return_loss_;
  ::webrtc::audioproc::Test_Statistic* echo_return_loss_;
  ::webrtc::audioproc::Test_Statistic* echo_return_loss_enhancement_;
  ::webrtc::audioproc::Test_Statistic* a_nlp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_unittest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_unittest_2eproto();
  #endif
  friend void protobuf_AssignDesc_unittest_2eproto();
  friend void protobuf_ShutdownFile_unittest_2eproto();

  void InitAsDefaultInstance();
  static Test_EchoMetrics* default_instance_;
};
// -------------------------------------------------------------------

class Test_DelayMetrics : public ::google::protobuf::MessageLite {
 public:
  Test_DelayMetrics();
  virtual ~Test_DelayMetrics();

  Test_DelayMetrics(const Test_DelayMetrics& from);

  inline Test_DelayMetrics& operator=(const Test_DelayMetrics& from) {
    CopyFrom(from);
    return *this;
  }

  static const Test_DelayMetrics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Test_DelayMetrics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Test_DelayMetrics* other);

  // implements Message ----------------------------------------------

  Test_DelayMetrics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Test_DelayMetrics& from);
  void MergeFrom(const Test_DelayMetrics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 median = 1;
  inline bool has_median() const;
  inline void clear_median();
  static const int kMedianFieldNumber = 1;
  inline ::google::protobuf::int32 median() const;
  inline void set_median(::google::protobuf::int32 value);

  // optional int32 std = 2;
  inline bool has_std() const;
  inline void clear_std();
  static const int kStdFieldNumber = 2;
  inline ::google::protobuf::int32 std() const;
  inline void set_std(::google::protobuf::int32 value);

  // optional float fraction_poor_delays = 3;
  inline bool has_fraction_poor_delays() const;
  inline void clear_fraction_poor_delays();
  static const int kFractionPoorDelaysFieldNumber = 3;
  inline float fraction_poor_delays() const;
  inline void set_fraction_poor_delays(float value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test.DelayMetrics)
 private:
  inline void set_has_median();
  inline void clear_has_median();
  inline void set_has_std();
  inline void clear_has_std();
  inline void set_has_fraction_poor_delays();
  inline void clear_has_fraction_poor_delays();

  ::google::protobuf::int32 median_;
  ::google::protobuf::int32 std_;
  float fraction_poor_delays_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_unittest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_unittest_2eproto();
  #endif
  friend void protobuf_AssignDesc_unittest_2eproto();
  friend void protobuf_ShutdownFile_unittest_2eproto();

  void InitAsDefaultInstance();
  static Test_DelayMetrics* default_instance_;
};
// -------------------------------------------------------------------

class Test : public ::google::protobuf::MessageLite {
 public:
  Test();
  virtual ~Test();

  Test(const Test& from);

  inline Test& operator=(const Test& from) {
    CopyFrom(from);
    return *this;
  }

  static const Test& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Test* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Test* other);

  // implements Message ----------------------------------------------

  Test* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Test& from);
  void MergeFrom(const Test& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Test_Frame Frame;
  typedef Test_Statistic Statistic;
  typedef Test_EchoMetrics EchoMetrics;
  typedef Test_DelayMetrics DelayMetrics;

  // accessors -------------------------------------------------------

  // optional int32 num_reverse_channels = 1;
  inline bool has_num_reverse_channels() const;
  inline void clear_num_reverse_channels();
  static const int kNumReverseChannelsFieldNumber = 1;
  inline ::google::protobuf::int32 num_reverse_channels() const;
  inline void set_num_reverse_channels(::google::protobuf::int32 value);

  // optional int32 num_input_channels = 2;
  inline bool has_num_input_channels() const;
  inline void clear_num_input_channels();
  static const int kNumInputChannelsFieldNumber = 2;
  inline ::google::protobuf::int32 num_input_channels() const;
  inline void set_num_input_channels(::google::protobuf::int32 value);

  // optional int32 num_output_channels = 3;
  inline bool has_num_output_channels() const;
  inline void clear_num_output_channels();
  static const int kNumOutputChannelsFieldNumber = 3;
  inline ::google::protobuf::int32 num_output_channels() const;
  inline void set_num_output_channels(::google::protobuf::int32 value);

  // optional int32 sample_rate = 4;
  inline bool has_sample_rate() const;
  inline void clear_sample_rate();
  static const int kSampleRateFieldNumber = 4;
  inline ::google::protobuf::int32 sample_rate() const;
  inline void set_sample_rate(::google::protobuf::int32 value);

  // repeated .webrtc.audioproc.Test.Frame frame = 5;
  inline int frame_size() const;
  inline void clear_frame();
  static const int kFrameFieldNumber = 5;
  inline const ::webrtc::audioproc::Test_Frame& frame(int index) const;
  inline ::webrtc::audioproc::Test_Frame* mutable_frame(int index);
  inline ::webrtc::audioproc::Test_Frame* add_frame();
  inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >&
      frame() const;
  inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >*
      mutable_frame();

  // optional int32 analog_level_average = 6;
  inline bool has_analog_level_average() const;
  inline void clear_analog_level_average();
  static const int kAnalogLevelAverageFieldNumber = 6;
  inline ::google::protobuf::int32 analog_level_average() const;
  inline void set_analog_level_average(::google::protobuf::int32 value);

  // optional int32 max_output_average = 7;
  inline bool has_max_output_average() const;
  inline void clear_max_output_average();
  static const int kMaxOutputAverageFieldNumber = 7;
  inline ::google::protobuf::int32 max_output_average() const;
  inline void set_max_output_average(::google::protobuf::int32 value);

  // optional int32 has_echo_count = 8;
  inline bool has_has_echo_count() const;
  inline void clear_has_echo_count();
  static const int kHasEchoCountFieldNumber = 8;
  inline ::google::protobuf::int32 has_echo_count() const;
  inline void set_has_echo_count(::google::protobuf::int32 value);

  // optional int32 has_voice_count = 9;
  inline bool has_has_voice_count() const;
  inline void clear_has_voice_count();
  static const int kHasVoiceCountFieldNumber = 9;
  inline ::google::protobuf::int32 has_voice_count() const;
  inline void set_has_voice_count(::google::protobuf::int32 value);

  // optional int32 is_saturated_count = 10;
  inline bool has_is_saturated_count() const;
  inline void clear_is_saturated_count();
  static const int kIsSaturatedCountFieldNumber = 10;
  inline ::google::protobuf::int32 is_saturated_count() const;
  inline void set_is_saturated_count(::google::protobuf::int32 value);

  // optional .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
  inline bool has_echo_metrics() const;
  inline void clear_echo_metrics();
  static const int kEchoMetricsFieldNumber = 11;
  inline const ::webrtc::audioproc::Test_EchoMetrics& echo_metrics() const;
  inline ::webrtc::audioproc::Test_EchoMetrics* mutable_echo_metrics();
  inline ::webrtc::audioproc::Test_EchoMetrics* release_echo_metrics();
  inline void set_allocated_echo_metrics(::webrtc::audioproc::Test_EchoMetrics* echo_metrics);

  // optional .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
  inline bool has_delay_metrics() const;
  inline void clear_delay_metrics();
  static const int kDelayMetricsFieldNumber = 12;
  inline const ::webrtc::audioproc::Test_DelayMetrics& delay_metrics() const;
  inline ::webrtc::audioproc::Test_DelayMetrics* mutable_delay_metrics();
  inline ::webrtc::audioproc::Test_DelayMetrics* release_delay_metrics();
  inline void set_allocated_delay_metrics(::webrtc::audioproc::Test_DelayMetrics* delay_metrics);

  // optional int32 rms_level = 13;
  inline bool has_rms_level() const;
  inline void clear_rms_level();
  static const int kRmsLevelFieldNumber = 13;
  inline ::google::protobuf::int32 rms_level() const;
  inline void set_rms_level(::google::protobuf::int32 value);

  // optional float ns_speech_probability_average = 14;
  inline bool has_ns_speech_probability_average() const;
  inline void clear_ns_speech_probability_average();
  static const int kNsSpeechProbabilityAverageFieldNumber = 14;
  inline float ns_speech_probability_average() const;
  inline void set_ns_speech_probability_average(float value);

  // optional bool use_aec_extended_filter = 15;
  inline bool has_use_aec_extended_filter() const;
  inline void clear_use_aec_extended_filter();
  static const int kUseAecExtendedFilterFieldNumber = 15;
  inline bool use_aec_extended_filter() const;
  inline void set_use_aec_extended_filter(bool value);

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.Test)
 private:
  inline void set_has_num_reverse_channels();
  inline void clear_has_num_reverse_channels();
  inline void set_has_num_input_channels();
  inline void clear_has_num_input_channels();
  inline void set_has_num_output_channels();
  inline void clear_has_num_output_channels();
  inline void set_has_sample_rate();
  inline void clear_has_sample_rate();
  inline void set_has_analog_level_average();
  inline void clear_has_analog_level_average();
  inline void set_has_max_output_average();
  inline void clear_has_max_output_average();
  inline void set_has_has_echo_count();
  inline void clear_has_has_echo_count();
  inline void set_has_has_voice_count();
  inline void clear_has_has_voice_count();
  inline void set_has_is_saturated_count();
  inline void clear_has_is_saturated_count();
  inline void set_has_echo_metrics();
  inline void clear_has_echo_metrics();
  inline void set_has_delay_metrics();
  inline void clear_has_delay_metrics();
  inline void set_has_rms_level();
  inline void clear_has_rms_level();
  inline void set_has_ns_speech_probability_average();
  inline void clear_has_ns_speech_probability_average();
  inline void set_has_use_aec_extended_filter();
  inline void clear_has_use_aec_extended_filter();

  ::google::protobuf::int32 num_reverse_channels_;
  ::google::protobuf::int32 num_input_channels_;
  ::google::protobuf::int32 num_output_channels_;
  ::google::protobuf::int32 sample_rate_;
  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame > frame_;
  ::google::protobuf::int32 analog_level_average_;
  ::google::protobuf::int32 max_output_average_;
  ::google::protobuf::int32 has_echo_count_;
  ::google::protobuf::int32 has_voice_count_;
  ::webrtc::audioproc::Test_EchoMetrics* echo_metrics_;
  ::google::protobuf::int32 is_saturated_count_;
  ::google::protobuf::int32 rms_level_;
  ::webrtc::audioproc::Test_DelayMetrics* delay_metrics_;
  float ns_speech_probability_average_;
  bool use_aec_extended_filter_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_unittest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_unittest_2eproto();
  #endif
  friend void protobuf_AssignDesc_unittest_2eproto();
  friend void protobuf_ShutdownFile_unittest_2eproto();

  void InitAsDefaultInstance();
  static Test* default_instance_;
};
// -------------------------------------------------------------------

class OutputData : public ::google::protobuf::MessageLite {
 public:
  OutputData();
  virtual ~OutputData();

  OutputData(const OutputData& from);

  inline OutputData& operator=(const OutputData& from) {
    CopyFrom(from);
    return *this;
  }

  static const OutputData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OutputData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OutputData* other);

  // implements Message ----------------------------------------------

  OutputData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OutputData& from);
  void MergeFrom(const OutputData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .webrtc.audioproc.Test test = 1;
  inline int test_size() const;
  inline void clear_test();
  static const int kTestFieldNumber = 1;
  inline const ::webrtc::audioproc::Test& test(int index) const;
  inline ::webrtc::audioproc::Test* mutable_test(int index);
  inline ::webrtc::audioproc::Test* add_test();
  inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >&
      test() const;
  inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >*
      mutable_test();

  // @@protoc_insertion_point(class_scope:webrtc.audioproc.OutputData)
 private:

  ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test > test_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_unittest_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_unittest_2eproto();
  #endif
  friend void protobuf_AssignDesc_unittest_2eproto();
  friend void protobuf_ShutdownFile_unittest_2eproto();

  void InitAsDefaultInstance();
  static OutputData* default_instance_;
};
// ===================================================================


// ===================================================================

// Test_Frame

// -------------------------------------------------------------------

// Test_Statistic

// optional int32 instant = 1;
inline bool Test_Statistic::has_instant() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_Statistic::set_has_instant() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_Statistic::clear_has_instant() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_Statistic::clear_instant() {
  instant_ = 0;
  clear_has_instant();
}
inline ::google::protobuf::int32 Test_Statistic::instant() const {
  return instant_;
}
inline void Test_Statistic::set_instant(::google::protobuf::int32 value) {
  set_has_instant();
  instant_ = value;
}

// optional int32 average = 2;
inline bool Test_Statistic::has_average() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_Statistic::set_has_average() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test_Statistic::clear_has_average() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test_Statistic::clear_average() {
  average_ = 0;
  clear_has_average();
}
inline ::google::protobuf::int32 Test_Statistic::average() const {
  return average_;
}
inline void Test_Statistic::set_average(::google::protobuf::int32 value) {
  set_has_average();
  average_ = value;
}

// optional int32 maximum = 3;
inline bool Test_Statistic::has_maximum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test_Statistic::set_has_maximum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test_Statistic::clear_has_maximum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test_Statistic::clear_maximum() {
  maximum_ = 0;
  clear_has_maximum();
}
inline ::google::protobuf::int32 Test_Statistic::maximum() const {
  return maximum_;
}
inline void Test_Statistic::set_maximum(::google::protobuf::int32 value) {
  set_has_maximum();
  maximum_ = value;
}

// optional int32 minimum = 4;
inline bool Test_Statistic::has_minimum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test_Statistic::set_has_minimum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test_Statistic::clear_has_minimum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test_Statistic::clear_minimum() {
  minimum_ = 0;
  clear_has_minimum();
}
inline ::google::protobuf::int32 Test_Statistic::minimum() const {
  return minimum_;
}
inline void Test_Statistic::set_minimum(::google::protobuf::int32 value) {
  set_has_minimum();
  minimum_ = value;
}

// -------------------------------------------------------------------

// Test_EchoMetrics

// optional .webrtc.audioproc.Test.Statistic residual_echo_return_loss = 1;
inline bool Test_EchoMetrics::has_residual_echo_return_loss() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_EchoMetrics::set_has_residual_echo_return_loss() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_EchoMetrics::clear_has_residual_echo_return_loss() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_EchoMetrics::clear_residual_echo_return_loss() {
  if (residual_echo_return_loss_ != NULL) residual_echo_return_loss_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_residual_echo_return_loss();
}
inline const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::residual_echo_return_loss() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return residual_echo_return_loss_ != NULL ? *residual_echo_return_loss_ : *default_instance().residual_echo_return_loss_;
#else
  return residual_echo_return_loss_ != NULL ? *residual_echo_return_loss_ : *default_instance_->residual_echo_return_loss_;
#endif
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_residual_echo_return_loss() {
  set_has_residual_echo_return_loss();
  if (residual_echo_return_loss_ == NULL) residual_echo_return_loss_ = new ::webrtc::audioproc::Test_Statistic;
  return residual_echo_return_loss_;
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_residual_echo_return_loss() {
  clear_has_residual_echo_return_loss();
  ::webrtc::audioproc::Test_Statistic* temp = residual_echo_return_loss_;
  residual_echo_return_loss_ = NULL;
  return temp;
}
inline void Test_EchoMetrics::set_allocated_residual_echo_return_loss(::webrtc::audioproc::Test_Statistic* residual_echo_return_loss) {
  delete residual_echo_return_loss_;
  residual_echo_return_loss_ = residual_echo_return_loss;
  if (residual_echo_return_loss) {
    set_has_residual_echo_return_loss();
  } else {
    clear_has_residual_echo_return_loss();
  }
}

// optional .webrtc.audioproc.Test.Statistic echo_return_loss = 2;
inline bool Test_EchoMetrics::has_echo_return_loss() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_EchoMetrics::set_has_echo_return_loss() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test_EchoMetrics::clear_has_echo_return_loss() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test_EchoMetrics::clear_echo_return_loss() {
  if (echo_return_loss_ != NULL) echo_return_loss_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_echo_return_loss();
}
inline const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::echo_return_loss() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return echo_return_loss_ != NULL ? *echo_return_loss_ : *default_instance().echo_return_loss_;
#else
  return echo_return_loss_ != NULL ? *echo_return_loss_ : *default_instance_->echo_return_loss_;
#endif
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_echo_return_loss() {
  set_has_echo_return_loss();
  if (echo_return_loss_ == NULL) echo_return_loss_ = new ::webrtc::audioproc::Test_Statistic;
  return echo_return_loss_;
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_echo_return_loss() {
  clear_has_echo_return_loss();
  ::webrtc::audioproc::Test_Statistic* temp = echo_return_loss_;
  echo_return_loss_ = NULL;
  return temp;
}
inline void Test_EchoMetrics::set_allocated_echo_return_loss(::webrtc::audioproc::Test_Statistic* echo_return_loss) {
  delete echo_return_loss_;
  echo_return_loss_ = echo_return_loss;
  if (echo_return_loss) {
    set_has_echo_return_loss();
  } else {
    clear_has_echo_return_loss();
  }
}

// optional .webrtc.audioproc.Test.Statistic echo_return_loss_enhancement = 3;
inline bool Test_EchoMetrics::has_echo_return_loss_enhancement() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test_EchoMetrics::set_has_echo_return_loss_enhancement() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test_EchoMetrics::clear_has_echo_return_loss_enhancement() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test_EchoMetrics::clear_echo_return_loss_enhancement() {
  if (echo_return_loss_enhancement_ != NULL) echo_return_loss_enhancement_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_echo_return_loss_enhancement();
}
inline const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::echo_return_loss_enhancement() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return echo_return_loss_enhancement_ != NULL ? *echo_return_loss_enhancement_ : *default_instance().echo_return_loss_enhancement_;
#else
  return echo_return_loss_enhancement_ != NULL ? *echo_return_loss_enhancement_ : *default_instance_->echo_return_loss_enhancement_;
#endif
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_echo_return_loss_enhancement() {
  set_has_echo_return_loss_enhancement();
  if (echo_return_loss_enhancement_ == NULL) echo_return_loss_enhancement_ = new ::webrtc::audioproc::Test_Statistic;
  return echo_return_loss_enhancement_;
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_echo_return_loss_enhancement() {
  clear_has_echo_return_loss_enhancement();
  ::webrtc::audioproc::Test_Statistic* temp = echo_return_loss_enhancement_;
  echo_return_loss_enhancement_ = NULL;
  return temp;
}
inline void Test_EchoMetrics::set_allocated_echo_return_loss_enhancement(::webrtc::audioproc::Test_Statistic* echo_return_loss_enhancement) {
  delete echo_return_loss_enhancement_;
  echo_return_loss_enhancement_ = echo_return_loss_enhancement;
  if (echo_return_loss_enhancement) {
    set_has_echo_return_loss_enhancement();
  } else {
    clear_has_echo_return_loss_enhancement();
  }
}

// optional .webrtc.audioproc.Test.Statistic a_nlp = 4;
inline bool Test_EchoMetrics::has_a_nlp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test_EchoMetrics::set_has_a_nlp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test_EchoMetrics::clear_has_a_nlp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test_EchoMetrics::clear_a_nlp() {
  if (a_nlp_ != NULL) a_nlp_->::webrtc::audioproc::Test_Statistic::Clear();
  clear_has_a_nlp();
}
inline const ::webrtc::audioproc::Test_Statistic& Test_EchoMetrics::a_nlp() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return a_nlp_ != NULL ? *a_nlp_ : *default_instance().a_nlp_;
#else
  return a_nlp_ != NULL ? *a_nlp_ : *default_instance_->a_nlp_;
#endif
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::mutable_a_nlp() {
  set_has_a_nlp();
  if (a_nlp_ == NULL) a_nlp_ = new ::webrtc::audioproc::Test_Statistic;
  return a_nlp_;
}
inline ::webrtc::audioproc::Test_Statistic* Test_EchoMetrics::release_a_nlp() {
  clear_has_a_nlp();
  ::webrtc::audioproc::Test_Statistic* temp = a_nlp_;
  a_nlp_ = NULL;
  return temp;
}
inline void Test_EchoMetrics::set_allocated_a_nlp(::webrtc::audioproc::Test_Statistic* a_nlp) {
  delete a_nlp_;
  a_nlp_ = a_nlp;
  if (a_nlp) {
    set_has_a_nlp();
  } else {
    clear_has_a_nlp();
  }
}

// -------------------------------------------------------------------

// Test_DelayMetrics

// optional int32 median = 1;
inline bool Test_DelayMetrics::has_median() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test_DelayMetrics::set_has_median() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test_DelayMetrics::clear_has_median() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test_DelayMetrics::clear_median() {
  median_ = 0;
  clear_has_median();
}
inline ::google::protobuf::int32 Test_DelayMetrics::median() const {
  return median_;
}
inline void Test_DelayMetrics::set_median(::google::protobuf::int32 value) {
  set_has_median();
  median_ = value;
}

// optional int32 std = 2;
inline bool Test_DelayMetrics::has_std() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test_DelayMetrics::set_has_std() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test_DelayMetrics::clear_has_std() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test_DelayMetrics::clear_std() {
  std_ = 0;
  clear_has_std();
}
inline ::google::protobuf::int32 Test_DelayMetrics::std() const {
  return std_;
}
inline void Test_DelayMetrics::set_std(::google::protobuf::int32 value) {
  set_has_std();
  std_ = value;
}

// optional float fraction_poor_delays = 3;
inline bool Test_DelayMetrics::has_fraction_poor_delays() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test_DelayMetrics::set_has_fraction_poor_delays() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test_DelayMetrics::clear_has_fraction_poor_delays() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test_DelayMetrics::clear_fraction_poor_delays() {
  fraction_poor_delays_ = 0;
  clear_has_fraction_poor_delays();
}
inline float Test_DelayMetrics::fraction_poor_delays() const {
  return fraction_poor_delays_;
}
inline void Test_DelayMetrics::set_fraction_poor_delays(float value) {
  set_has_fraction_poor_delays();
  fraction_poor_delays_ = value;
}

// -------------------------------------------------------------------

// Test

// optional int32 num_reverse_channels = 1;
inline bool Test::has_num_reverse_channels() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Test::set_has_num_reverse_channels() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Test::clear_has_num_reverse_channels() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Test::clear_num_reverse_channels() {
  num_reverse_channels_ = 0;
  clear_has_num_reverse_channels();
}
inline ::google::protobuf::int32 Test::num_reverse_channels() const {
  return num_reverse_channels_;
}
inline void Test::set_num_reverse_channels(::google::protobuf::int32 value) {
  set_has_num_reverse_channels();
  num_reverse_channels_ = value;
}

// optional int32 num_input_channels = 2;
inline bool Test::has_num_input_channels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Test::set_has_num_input_channels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Test::clear_has_num_input_channels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Test::clear_num_input_channels() {
  num_input_channels_ = 0;
  clear_has_num_input_channels();
}
inline ::google::protobuf::int32 Test::num_input_channels() const {
  return num_input_channels_;
}
inline void Test::set_num_input_channels(::google::protobuf::int32 value) {
  set_has_num_input_channels();
  num_input_channels_ = value;
}

// optional int32 num_output_channels = 3;
inline bool Test::has_num_output_channels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Test::set_has_num_output_channels() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Test::clear_has_num_output_channels() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Test::clear_num_output_channels() {
  num_output_channels_ = 0;
  clear_has_num_output_channels();
}
inline ::google::protobuf::int32 Test::num_output_channels() const {
  return num_output_channels_;
}
inline void Test::set_num_output_channels(::google::protobuf::int32 value) {
  set_has_num_output_channels();
  num_output_channels_ = value;
}

// optional int32 sample_rate = 4;
inline bool Test::has_sample_rate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Test::set_has_sample_rate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Test::clear_has_sample_rate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Test::clear_sample_rate() {
  sample_rate_ = 0;
  clear_has_sample_rate();
}
inline ::google::protobuf::int32 Test::sample_rate() const {
  return sample_rate_;
}
inline void Test::set_sample_rate(::google::protobuf::int32 value) {
  set_has_sample_rate();
  sample_rate_ = value;
}

// repeated .webrtc.audioproc.Test.Frame frame = 5;
inline int Test::frame_size() const {
  return frame_.size();
}
inline void Test::clear_frame() {
  frame_.Clear();
}
inline const ::webrtc::audioproc::Test_Frame& Test::frame(int index) const {
  return frame_.Get(index);
}
inline ::webrtc::audioproc::Test_Frame* Test::mutable_frame(int index) {
  return frame_.Mutable(index);
}
inline ::webrtc::audioproc::Test_Frame* Test::add_frame() {
  return frame_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >&
Test::frame() const {
  return frame_;
}
inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test_Frame >*
Test::mutable_frame() {
  return &frame_;
}

// optional int32 analog_level_average = 6;
inline bool Test::has_analog_level_average() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Test::set_has_analog_level_average() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Test::clear_has_analog_level_average() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Test::clear_analog_level_average() {
  analog_level_average_ = 0;
  clear_has_analog_level_average();
}
inline ::google::protobuf::int32 Test::analog_level_average() const {
  return analog_level_average_;
}
inline void Test::set_analog_level_average(::google::protobuf::int32 value) {
  set_has_analog_level_average();
  analog_level_average_ = value;
}

// optional int32 max_output_average = 7;
inline bool Test::has_max_output_average() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Test::set_has_max_output_average() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Test::clear_has_max_output_average() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Test::clear_max_output_average() {
  max_output_average_ = 0;
  clear_has_max_output_average();
}
inline ::google::protobuf::int32 Test::max_output_average() const {
  return max_output_average_;
}
inline void Test::set_max_output_average(::google::protobuf::int32 value) {
  set_has_max_output_average();
  max_output_average_ = value;
}

// optional int32 has_echo_count = 8;
inline bool Test::has_has_echo_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Test::set_has_has_echo_count() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Test::clear_has_has_echo_count() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Test::clear_has_echo_count() {
  has_echo_count_ = 0;
  clear_has_has_echo_count();
}
inline ::google::protobuf::int32 Test::has_echo_count() const {
  return has_echo_count_;
}
inline void Test::set_has_echo_count(::google::protobuf::int32 value) {
  set_has_has_echo_count();
  has_echo_count_ = value;
}

// optional int32 has_voice_count = 9;
inline bool Test::has_has_voice_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Test::set_has_has_voice_count() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Test::clear_has_has_voice_count() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Test::clear_has_voice_count() {
  has_voice_count_ = 0;
  clear_has_has_voice_count();
}
inline ::google::protobuf::int32 Test::has_voice_count() const {
  return has_voice_count_;
}
inline void Test::set_has_voice_count(::google::protobuf::int32 value) {
  set_has_has_voice_count();
  has_voice_count_ = value;
}

// optional int32 is_saturated_count = 10;
inline bool Test::has_is_saturated_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Test::set_has_is_saturated_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Test::clear_has_is_saturated_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Test::clear_is_saturated_count() {
  is_saturated_count_ = 0;
  clear_has_is_saturated_count();
}
inline ::google::protobuf::int32 Test::is_saturated_count() const {
  return is_saturated_count_;
}
inline void Test::set_is_saturated_count(::google::protobuf::int32 value) {
  set_has_is_saturated_count();
  is_saturated_count_ = value;
}

// optional .webrtc.audioproc.Test.EchoMetrics echo_metrics = 11;
inline bool Test::has_echo_metrics() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Test::set_has_echo_metrics() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Test::clear_has_echo_metrics() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Test::clear_echo_metrics() {
  if (echo_metrics_ != NULL) echo_metrics_->::webrtc::audioproc::Test_EchoMetrics::Clear();
  clear_has_echo_metrics();
}
inline const ::webrtc::audioproc::Test_EchoMetrics& Test::echo_metrics() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return echo_metrics_ != NULL ? *echo_metrics_ : *default_instance().echo_metrics_;
#else
  return echo_metrics_ != NULL ? *echo_metrics_ : *default_instance_->echo_metrics_;
#endif
}
inline ::webrtc::audioproc::Test_EchoMetrics* Test::mutable_echo_metrics() {
  set_has_echo_metrics();
  if (echo_metrics_ == NULL) echo_metrics_ = new ::webrtc::audioproc::Test_EchoMetrics;
  return echo_metrics_;
}
inline ::webrtc::audioproc::Test_EchoMetrics* Test::release_echo_metrics() {
  clear_has_echo_metrics();
  ::webrtc::audioproc::Test_EchoMetrics* temp = echo_metrics_;
  echo_metrics_ = NULL;
  return temp;
}
inline void Test::set_allocated_echo_metrics(::webrtc::audioproc::Test_EchoMetrics* echo_metrics) {
  delete echo_metrics_;
  echo_metrics_ = echo_metrics;
  if (echo_metrics) {
    set_has_echo_metrics();
  } else {
    clear_has_echo_metrics();
  }
}

// optional .webrtc.audioproc.Test.DelayMetrics delay_metrics = 12;
inline bool Test::has_delay_metrics() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Test::set_has_delay_metrics() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Test::clear_has_delay_metrics() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Test::clear_delay_metrics() {
  if (delay_metrics_ != NULL) delay_metrics_->::webrtc::audioproc::Test_DelayMetrics::Clear();
  clear_has_delay_metrics();
}
inline const ::webrtc::audioproc::Test_DelayMetrics& Test::delay_metrics() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return delay_metrics_ != NULL ? *delay_metrics_ : *default_instance().delay_metrics_;
#else
  return delay_metrics_ != NULL ? *delay_metrics_ : *default_instance_->delay_metrics_;
#endif
}
inline ::webrtc::audioproc::Test_DelayMetrics* Test::mutable_delay_metrics() {
  set_has_delay_metrics();
  if (delay_metrics_ == NULL) delay_metrics_ = new ::webrtc::audioproc::Test_DelayMetrics;
  return delay_metrics_;
}
inline ::webrtc::audioproc::Test_DelayMetrics* Test::release_delay_metrics() {
  clear_has_delay_metrics();
  ::webrtc::audioproc::Test_DelayMetrics* temp = delay_metrics_;
  delay_metrics_ = NULL;
  return temp;
}
inline void Test::set_allocated_delay_metrics(::webrtc::audioproc::Test_DelayMetrics* delay_metrics) {
  delete delay_metrics_;
  delay_metrics_ = delay_metrics;
  if (delay_metrics) {
    set_has_delay_metrics();
  } else {
    clear_has_delay_metrics();
  }
}

// optional int32 rms_level = 13;
inline bool Test::has_rms_level() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Test::set_has_rms_level() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Test::clear_has_rms_level() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Test::clear_rms_level() {
  rms_level_ = 0;
  clear_has_rms_level();
}
inline ::google::protobuf::int32 Test::rms_level() const {
  return rms_level_;
}
inline void Test::set_rms_level(::google::protobuf::int32 value) {
  set_has_rms_level();
  rms_level_ = value;
}

// optional float ns_speech_probability_average = 14;
inline bool Test::has_ns_speech_probability_average() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Test::set_has_ns_speech_probability_average() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Test::clear_has_ns_speech_probability_average() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Test::clear_ns_speech_probability_average() {
  ns_speech_probability_average_ = 0;
  clear_has_ns_speech_probability_average();
}
inline float Test::ns_speech_probability_average() const {
  return ns_speech_probability_average_;
}
inline void Test::set_ns_speech_probability_average(float value) {
  set_has_ns_speech_probability_average();
  ns_speech_probability_average_ = value;
}

// optional bool use_aec_extended_filter = 15;
inline bool Test::has_use_aec_extended_filter() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Test::set_has_use_aec_extended_filter() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Test::clear_has_use_aec_extended_filter() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Test::clear_use_aec_extended_filter() {
  use_aec_extended_filter_ = false;
  clear_has_use_aec_extended_filter();
}
inline bool Test::use_aec_extended_filter() const {
  return use_aec_extended_filter_;
}
inline void Test::set_use_aec_extended_filter(bool value) {
  set_has_use_aec_extended_filter();
  use_aec_extended_filter_ = value;
}

// -------------------------------------------------------------------

// OutputData

// repeated .webrtc.audioproc.Test test = 1;
inline int OutputData::test_size() const {
  return test_.size();
}
inline void OutputData::clear_test() {
  test_.Clear();
}
inline const ::webrtc::audioproc::Test& OutputData::test(int index) const {
  return test_.Get(index);
}
inline ::webrtc::audioproc::Test* OutputData::mutable_test(int index) {
  return test_.Mutable(index);
}
inline ::webrtc::audioproc::Test* OutputData::add_test() {
  return test_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >&
OutputData::test() const {
  return test_;
}
inline ::google::protobuf::RepeatedPtrField< ::webrtc::audioproc::Test >*
OutputData::mutable_test() {
  return &test_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace audioproc
}  // namespace webrtc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_unittest_2eproto__INCLUDED
